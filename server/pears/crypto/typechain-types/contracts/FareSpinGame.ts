/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "../common";

export declare namespace FareSpinGame {
  export type EntryStruct = {
    player: string;
    amount: BigNumberish;
    winAmount: BigNumberish;
    gameModeId: BigNumberish;
    pickedNumber: BigNumberish;
    roundId: BigNumberish;
    settled: boolean;
  };

  export type EntryStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    player: string;
    amount: BigNumber;
    winAmount: BigNumber;
    gameModeId: BigNumber;
    pickedNumber: BigNumber;
    roundId: BigNumber;
    settled: boolean;
  };

  export type EntryParamStruct = {
    amount: BigNumberish;
    gameModeId: BigNumberish;
    pickedNumber: BigNumberish;
  };

  export type EntryParamStructOutput = [BigNumber, BigNumber, BigNumber] & {
    amount: BigNumber;
    gameModeId: BigNumber;
    pickedNumber: BigNumber;
  };
}

export interface FareSpinGameInterface extends utils.Interface {
  functions: {
    "batchEntryMap(uint256,uint256)": FunctionFragment;
    "checkEliminator(uint256,uint256)": FunctionFragment;
    "eliminators(uint256,uint256)": FunctionFragment;
    "entryMap(uint256,uint256)": FunctionFragment;
    "fareTokenAddress()": FunctionFragment;
    "gameEdgeCeiling()": FunctionFragment;
    "gameModes(uint256)": FunctionFragment;
    "getBatchEntryCount(uint256)": FunctionFragment;
    "getCurrentEntryId()": FunctionFragment;
    "getCurrentGameModeId()": FunctionFragment;
    "getCurrentRoundId()": FunctionFragment;
    "getEntry(uint256,uint256)": FunctionFragment;
    "getEntryCount(uint256)": FunctionFragment;
    "getIsEliminator(uint256,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "placeEntries((uint256,uint256,uint256)[])": FunctionFragment;
    "rawFulfillRandomness(bytes32,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rounds(uint256)": FunctionFragment;
    "setGameMode(uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "setTreasuryAddress(address)": FunctionFragment;
    "setTreasuryMint(uint256)": FunctionFragment;
    "settleBatchEntry(uint256,uint256)": FunctionFragment;
    "strToUint(string)": FunctionFragment;
    "testFulfillRandomness()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "treasuryAddress()": FunctionFragment;
    "treasuryMint()": FunctionFragment;
    "vrfMap(bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "batchEntryMap"
      | "checkEliminator"
      | "eliminators"
      | "entryMap"
      | "fareTokenAddress"
      | "gameEdgeCeiling"
      | "gameModes"
      | "getBatchEntryCount"
      | "getCurrentEntryId"
      | "getCurrentGameModeId"
      | "getCurrentRoundId"
      | "getEntry"
      | "getEntryCount"
      | "getIsEliminator"
      | "owner"
      | "placeEntries"
      | "rawFulfillRandomness"
      | "renounceOwnership"
      | "rounds"
      | "setGameMode"
      | "setTreasuryAddress"
      | "setTreasuryMint"
      | "settleBatchEntry"
      | "strToUint"
      | "testFulfillRandomness"
      | "transferOwnership"
      | "treasuryAddress"
      | "treasuryMint"
      | "vrfMap"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "batchEntryMap",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "checkEliminator",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "eliminators",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "entryMap",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "fareTokenAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "gameEdgeCeiling",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "gameModes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getBatchEntryCount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentEntryId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentGameModeId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentRoundId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getEntry",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getEntryCount",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getIsEliminator",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "placeEntries",
    values: [FareSpinGame.EntryParamStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "rawFulfillRandomness",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rounds",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setGameMode",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setTreasuryAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTreasuryMint",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "settleBatchEntry",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "strToUint", values: [string]): string;
  encodeFunctionData(
    functionFragment: "testFulfillRandomness",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "treasuryAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "treasuryMint",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "vrfMap", values: [BytesLike]): string;

  decodeFunctionResult(
    functionFragment: "batchEntryMap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkEliminator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eliminators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "entryMap", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fareTokenAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "gameEdgeCeiling",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gameModes", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getBatchEntryCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentEntryId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentGameModeId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentRoundId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getEntry", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getEntryCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getIsEliminator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "placeEntries",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rawFulfillRandomness",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "rounds", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setGameMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTreasuryAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTreasuryMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "settleBatchEntry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "strToUint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "testFulfillRandomness",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "treasuryAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "treasuryMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vrfMap", data: BytesLike): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface FareSpinGame extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FareSpinGameInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    batchEntryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, boolean, BigNumber, BigNumber] & {
        entryId: BigNumber;
        player: string;
        settled: boolean;
        totalEntryAmount: BigNumber;
        totalWinAmount: BigNumber;
      }
    >;

    checkEliminator(
      gameModeId: BigNumberish,
      randomEliminator: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isEliminator: boolean }>;

    eliminators(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        id: BigNumber;
        randomEliminator: BigNumber;
        isEliminator: boolean;
      }
    >;

    entryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        player: string;
        amount: BigNumber;
        winAmount: BigNumber;
        gameModeId: BigNumber;
        pickedNumber: BigNumber;
        roundId: BigNumber;
        settled: boolean;
      }
    >;

    fareTokenAddress(overrides?: CallOverrides): Promise<[string]>;

    gameEdgeCeiling(overrides?: CallOverrides): Promise<[BigNumber]>;

    gameModes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        id: BigNumber;
        cardinality: BigNumber;
        gameEdgeFloor: BigNumber;
        mintMultiplier: BigNumber;
        minAmount: BigNumber;
        maxAmount: BigNumber;
      }
    >;

    getBatchEntryCount(
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    getCurrentEntryId(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id: BigNumber }>;

    getCurrentGameModeId(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id: BigNumber }>;

    getCurrentRoundId(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { id: BigNumber }>;

    getEntry(
      entryId: BigNumberish,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [FareSpinGame.EntryStructOutput] & {
        entry: FareSpinGame.EntryStructOutput;
      }
    >;

    getEntryCount(
      entryId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    getIsEliminator(
      gameModeId: BigNumberish,
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { isEliminator: boolean }>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    placeEntries(
      batchEntry: FareSpinGame.EntryParamStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rawFulfillRandomness(
      requestId: BytesLike,
      randomness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    rounds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        id: BigNumber;
        randomNum: BigNumber;
        vrfRequestId: string;
      }
    >;

    setGameMode(
      cardinality: BigNumberish,
      gameEdgeFloor: BigNumberish,
      mintMultiplier: BigNumberish,
      minAmount: BigNumberish,
      maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTreasuryAddress(
      _treasuryAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTreasuryMint(
      percent: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    settleBatchEntry(
      roundId: BigNumberish,
      batchEntryId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    strToUint(
      _str: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { res: BigNumber }>;

    testFulfillRandomness(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    treasuryAddress(overrides?: CallOverrides): Promise<[string]>;

    treasuryMint(overrides?: CallOverrides): Promise<[BigNumber]>;

    vrfMap(arg0: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  batchEntryMap(
    arg0: BigNumberish,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, string, boolean, BigNumber, BigNumber] & {
      entryId: BigNumber;
      player: string;
      settled: boolean;
      totalEntryAmount: BigNumber;
      totalWinAmount: BigNumber;
    }
  >;

  checkEliminator(
    gameModeId: BigNumberish,
    randomEliminator: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  eliminators(
    arg0: BigNumberish,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, boolean] & {
      id: BigNumber;
      randomEliminator: BigNumber;
      isEliminator: boolean;
    }
  >;

  entryMap(
    arg0: BigNumberish,
    arg1: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, boolean] & {
      player: string;
      amount: BigNumber;
      winAmount: BigNumber;
      gameModeId: BigNumber;
      pickedNumber: BigNumber;
      roundId: BigNumber;
      settled: boolean;
    }
  >;

  fareTokenAddress(overrides?: CallOverrides): Promise<string>;

  gameEdgeCeiling(overrides?: CallOverrides): Promise<BigNumber>;

  gameModes(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      id: BigNumber;
      cardinality: BigNumber;
      gameEdgeFloor: BigNumber;
      mintMultiplier: BigNumber;
      minAmount: BigNumber;
      maxAmount: BigNumber;
    }
  >;

  getBatchEntryCount(
    roundId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getCurrentEntryId(overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentGameModeId(overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentRoundId(overrides?: CallOverrides): Promise<BigNumber>;

  getEntry(
    entryId: BigNumberish,
    idx: BigNumberish,
    overrides?: CallOverrides
  ): Promise<FareSpinGame.EntryStructOutput>;

  getEntryCount(
    entryId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getIsEliminator(
    gameModeId: BigNumberish,
    roundId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  placeEntries(
    batchEntry: FareSpinGame.EntryParamStruct[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rawFulfillRandomness(
    requestId: BytesLike,
    randomness: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  rounds(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string] & {
      id: BigNumber;
      randomNum: BigNumber;
      vrfRequestId: string;
    }
  >;

  setGameMode(
    cardinality: BigNumberish,
    gameEdgeFloor: BigNumberish,
    mintMultiplier: BigNumberish,
    minAmount: BigNumberish,
    maxAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTreasuryAddress(
    _treasuryAddress: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTreasuryMint(
    percent: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  settleBatchEntry(
    roundId: BigNumberish,
    batchEntryId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  strToUint(_str: string, overrides?: CallOverrides): Promise<BigNumber>;

  testFulfillRandomness(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  treasuryAddress(overrides?: CallOverrides): Promise<string>;

  treasuryMint(overrides?: CallOverrides): Promise<BigNumber>;

  vrfMap(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    batchEntryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, string, boolean, BigNumber, BigNumber] & {
        entryId: BigNumber;
        player: string;
        settled: boolean;
        totalEntryAmount: BigNumber;
        totalWinAmount: BigNumber;
      }
    >;

    checkEliminator(
      gameModeId: BigNumberish,
      randomEliminator: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    eliminators(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, boolean] & {
        id: BigNumber;
        randomEliminator: BigNumber;
        isEliminator: boolean;
      }
    >;

    entryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean
      ] & {
        player: string;
        amount: BigNumber;
        winAmount: BigNumber;
        gameModeId: BigNumber;
        pickedNumber: BigNumber;
        roundId: BigNumber;
        settled: boolean;
      }
    >;

    fareTokenAddress(overrides?: CallOverrides): Promise<string>;

    gameEdgeCeiling(overrides?: CallOverrides): Promise<BigNumber>;

    gameModes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        id: BigNumber;
        cardinality: BigNumber;
        gameEdgeFloor: BigNumber;
        mintMultiplier: BigNumber;
        minAmount: BigNumber;
        maxAmount: BigNumber;
      }
    >;

    getBatchEntryCount(
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrentEntryId(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentGameModeId(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentRoundId(overrides?: CallOverrides): Promise<BigNumber>;

    getEntry(
      entryId: BigNumberish,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<FareSpinGame.EntryStructOutput>;

    getEntryCount(
      entryId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIsEliminator(
      gameModeId: BigNumberish,
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    placeEntries(
      batchEntry: FareSpinGame.EntryParamStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    rawFulfillRandomness(
      requestId: BytesLike,
      randomness: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rounds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string] & {
        id: BigNumber;
        randomNum: BigNumber;
        vrfRequestId: string;
      }
    >;

    setGameMode(
      cardinality: BigNumberish,
      gameEdgeFloor: BigNumberish,
      mintMultiplier: BigNumberish,
      minAmount: BigNumberish,
      maxAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setTreasuryAddress(
      _treasuryAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setTreasuryMint(
      percent: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    settleBatchEntry(
      roundId: BigNumberish,
      batchEntryId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    strToUint(_str: string, overrides?: CallOverrides): Promise<BigNumber>;

    testFulfillRandomness(overrides?: CallOverrides): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    treasuryAddress(overrides?: CallOverrides): Promise<string>;

    treasuryMint(overrides?: CallOverrides): Promise<BigNumber>;

    vrfMap(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    batchEntryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    checkEliminator(
      gameModeId: BigNumberish,
      randomEliminator: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    eliminators(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    entryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fareTokenAddress(overrides?: CallOverrides): Promise<BigNumber>;

    gameEdgeCeiling(overrides?: CallOverrides): Promise<BigNumber>;

    gameModes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getBatchEntryCount(
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCurrentEntryId(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentGameModeId(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentRoundId(overrides?: CallOverrides): Promise<BigNumber>;

    getEntry(
      entryId: BigNumberish,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getEntryCount(
      entryId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getIsEliminator(
      gameModeId: BigNumberish,
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    placeEntries(
      batchEntry: FareSpinGame.EntryParamStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rawFulfillRandomness(
      requestId: BytesLike,
      randomness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    rounds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    setGameMode(
      cardinality: BigNumberish,
      gameEdgeFloor: BigNumberish,
      mintMultiplier: BigNumberish,
      minAmount: BigNumberish,
      maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTreasuryAddress(
      _treasuryAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTreasuryMint(
      percent: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    settleBatchEntry(
      roundId: BigNumberish,
      batchEntryId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    strToUint(_str: string, overrides?: CallOverrides): Promise<BigNumber>;

    testFulfillRandomness(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    treasuryAddress(overrides?: CallOverrides): Promise<BigNumber>;

    treasuryMint(overrides?: CallOverrides): Promise<BigNumber>;

    vrfMap(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    batchEntryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    checkEliminator(
      gameModeId: BigNumberish,
      randomEliminator: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    eliminators(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    entryMap(
      arg0: BigNumberish,
      arg1: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fareTokenAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameEdgeCeiling(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    gameModes(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getBatchEntryCount(
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentEntryId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentGameModeId(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCurrentRoundId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getEntry(
      entryId: BigNumberish,
      idx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getEntryCount(
      entryId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getIsEliminator(
      gameModeId: BigNumberish,
      roundId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    placeEntries(
      batchEntry: FareSpinGame.EntryParamStruct[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rawFulfillRandomness(
      requestId: BytesLike,
      randomness: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    rounds(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setGameMode(
      cardinality: BigNumberish,
      gameEdgeFloor: BigNumberish,
      mintMultiplier: BigNumberish,
      minAmount: BigNumberish,
      maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTreasuryAddress(
      _treasuryAddress: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTreasuryMint(
      percent: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    settleBatchEntry(
      roundId: BigNumberish,
      batchEntryId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    strToUint(
      _str: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    testFulfillRandomness(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    treasuryAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    treasuryMint(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    vrfMap(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
